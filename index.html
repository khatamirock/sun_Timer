<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sun Angle Simulation - Dhaka, Bangladesh</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #333;
            transition: background 1s ease;
        }
        
        .container {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 800px;
            width: 100%;
            transition: background-color 1s ease;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #1a5276;
        }
        
        .location {
            text-align: center;
            margin-bottom: 20px;
            color: #2874a6;
            font-size: 1.1em;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        label {
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, button {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        #protractorCanvas {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .info-panel {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .info-card {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            flex: 1;
            min-width: 150px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: background-color 1s ease;
        }
        
        .info-card h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .info-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #3498db;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #speedSlider {
            width: 150px;
        }
        
        .sky-gradient {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
            pointer-events: none;
            z-index: -1;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }
            .controls {
                flex-direction: column;
                gap: 15px;
            }
            .info-panel {
                flex-direction: column;
                gap: 10px;
            }
            h1 {
                font-size: 1.8em;
            }
            .info-value {
                font-size: 1.3em;
            }
            .control-group {
                width: 100%;
                align-items: stretch;
            }
            input[type="date"], input[type="time"] {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5em;
            }
            .info-value {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Sun Angle Simulation</h1>
        <div class="location">Dhaka, Bangladesh (23.8103째 N, 90.4125째 E)</div>
        
        <div class="controls">
            <div class="control-group">
                <label for="dateInput">Date:</label>
                <input type="date" id="dateInput">
            </div>
            
            <div class="control-group">
                <label for="timeInput">Time:</label>
                <input type="time" id="timeInput">
            </div>
            
            <div class="control-group">
                <button id="playButton">Play</button>
            </div>
            
            <div class="control-group speed-control">
                <label for="speedSlider">Speed:</label>
                <!-- UPDATED: Increased the max value of the slider to 3600 to allow for hourly speeds -->
                <input type="range" id="speedSlider" min="1" max="3600" value="60">
                <span id="speedValue">60x</span>
            </div>
        </div>
        
        <div class="canvas-container">
            <div class="sky-gradient" id="skyGradient"></div>
            <canvas id="protractorCanvas"></canvas>
        </div>
        
        <div class="info-panel">
            <div class="info-card">
                <h3>Current Time</h3>
                <div class="info-value" id="currentTime">--:--:--</div>
            </div>
            
            <div class="info-card">
                <h3>Sun Angle</h3>
                <div class="info-value" id="sunAngle">--째</div>
            </div>
            
            <div class="info-card">
                <h3>Azimuth</h3>
                <div class="info-value" id="azimuth">--째</div>
            </div>
            
            <div class="info-card">
                <h3>Sunrise</h3>
                <div class="info-value" id="sunrise">--:--</div>
            </div>
            
            <div class="info-card">
                <h3>Sunset</h3>
                <div class="info-value" id="sunset">--:--</div>
            </div>
        </div>
    </div>
    <script>
        // Constants for Dhaka, Bangladesh
        const LATITUDE = 23.8103; // North
        const LONGITUDE = 90.4125; // East
        
        // Canvas setup
        const canvas = document.getElementById('protractorCanvas');
        const ctx = canvas.getContext('2d');
        let centerX, centerY, radius;
        
        // UI elements
        const dateInput = document.getElementById('dateInput');
        const timeInput = document.getElementById('timeInput');
        const playButton = document.getElementById('playButton');
        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');
        const currentTimeElement = document.getElementById('currentTime');
        const sunAngleElement = document.getElementById('sunAngle');
        const azimuthElement = document.getElementById('azimuth');
        const sunriseElement = document.getElementById('sunrise');
        const sunsetElement = document.getElementById('sunset');
        const skyGradient = document.getElementById('skyGradient');
        const bodyElement = document.body;
        const containerElement = document.querySelector('.container');
        const infoCards = document.querySelectorAll('.info-card');
        
        // Simulation state
        let isPlaying = false;
        let simulationDate = new Date();
        let animationId = null;
        let lastTimestamp = 0;
        
        // Initialize date and time inputs with current values
        function initializeDateTime() {
            const now = new Date();
            dateInput.value = formatDate(now);
            timeInput.value = formatTime(now);
            simulationDate = new Date(now);
        }
        
        // Format date for input element
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Format time for input element
        function formatTime(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }
        
        // Format time with seconds
        function formatTimeWithSeconds(date) {
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        
        // Update background based on sun elevation
        function updateBackground(elevation) {
            // Normalize elevation to a 0-1 scale (0 = horizon, 1 = zenith)
            const normalizedElevation = Math.max(0, Math.min(1, elevation / 90));
            
            // Calculate colors based on elevation
            // When sun is low (0): dark blue to black
            // When sun is high (1): light blue to white
            let topColor, bottomColor, containerBg, cardBg, textColor;
            
            if (elevation <= 0) {
                // Night time
                topColor = '#0a1128';
                bottomColor = '#001f3f';
                containerBg = 'rgba(20, 30, 48, 0.9)';
                cardBg = 'rgba(30, 40, 60, 0.9)';
                textColor = '#e0e0e0';
            } else if (elevation < 10) {
                // Dawn/Dusk
                const factor = elevation / 10;
                topColor = interpolateColor('#0a1128', '#ff7043', factor);
                bottomColor = interpolateColor('#001f3f', '#d84315', factor);
                containerBg = interpolateColor('rgba(20, 30, 48, 0.9)', 'rgba(40, 30, 60, 0.9)', factor);
                cardBg = interpolateColor('rgba(30, 40, 60, 0.9)', 'rgba(50, 40, 70, 0.9)', factor);
                textColor = interpolateColor('#e0e0e0', '#f5f5f5', factor);
            } else if (elevation < 30) {
                // Morning/Late Afternoon
                const factor = (elevation - 10) / 20;
                topColor = interpolateColor('#ff7043', '#64b5f6', factor);
                bottomColor = interpolateColor('#d84315', '#bbdefb', factor);
                containerBg = interpolateColor('rgba(40, 30, 60, 0.9)', 'rgba(255, 255, 255, 0.9)', factor);
                cardBg = interpolateColor('rgba(50, 40, 70, 0.9)', 'rgba(248, 249, 250, 0.9)', factor);
                textColor = interpolateColor('#f5f5f5', '#333333', factor);
            } else {
                // Midday
                const factor = Math.min(1, (elevation - 30) / 60);
                topColor = interpolateColor('#64b5f6', '#87CEEB', factor);
                bottomColor = interpolateColor('#bbdefb', '#ffffff', factor);
                containerBg = 'rgba(255, 255, 255, 0.9)';
                cardBg = 'rgba(248, 249, 250, 0.9)';
                textColor = '#333333';
            }
            
            // Apply colors to elements
            bodyElement.style.background = `linear-gradient(to bottom, ${topColor}, ${bottomColor})`;
            containerElement.style.backgroundColor = containerBg;
            
            infoCards.forEach(card => {
                card.style.backgroundColor = cardBg;
                card.querySelector('h3').style.color = textColor;
                card.querySelector('.info-value').style.color = textColor === '#333333' ? '#3498db' : '#64b5f6';
            });
            
            // Update text colors for headings and location
            document.querySelector('h1').style.color = textColor === '#333333' ? '#1a5276' : '#e0e0e0';
            document.querySelector('.location').style.color = textColor === '#333333' ? '#2874a6' : '#a0c4e0';
        }
        
        // Helper function to interpolate between two colors
        function interpolateColor(color1, color2, factor) {
            // Convert hex to RGB
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            
            if (!c1 || !c2) return color1;
            
            // Interpolate RGB values
            const r = Math.round(c1.r + (c2.r - c1.r) * factor);
            const g = Math.round(c1.g + (c2.g - c1.g) * factor);
            const b = Math.round(c1.b + (c2.b - c1.b) * factor);
            
            // Convert back to hex
            return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        }
        
        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            // Handle rgba format
            if (hex.startsWith('rgba')) {
                const matches = hex.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if (matches) {
                    return {
                        r: parseInt(matches[1]),
                        g: parseInt(matches[2]),
                        b: parseInt(matches[3])
                    };
                }
                return null;
            }
            
            // Remove # if present
            hex = hex.replace('#', '');
            
            // Parse hex values
            const bigint = parseInt(hex, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        }
        
        // Draw protractor
        function drawProtractor() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw protractor arc
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 0, false);
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw base line
            ctx.beginPath();
            ctx.moveTo(centerX - radius - 20, centerY);
            ctx.lineTo(centerX + radius + 20, centerY);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw angle markings and labels
            ctx.font = `${Math.max(10, radius * 0.04)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (let angle = 0; angle <= 180; angle += 10) {
                const radian = (180 - angle) * Math.PI / 180;
                const x1 = centerX + (radius - 10) * Math.cos(radian);
                const y1 = centerY - (radius - 10) * Math.sin(radian);
                const x2 = centerX + radius * Math.cos(radian);
                const y2 = centerY - radius * Math.sin(radian);
                
                // Draw tick mark
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = angle % 30 === 0 ? '#e74c3c' : '#333';
                ctx.lineWidth = angle % 30 === 0 ? 2 : 1;
                ctx.stroke();
                
                // Draw angle label
                if (angle % 30 === 0) {
                    const labelX = centerX + (radius - 30) * Math.cos(radian);
                    const labelY = centerY - (radius - 30) * Math.sin(radian);
                    
                    ctx.fillStyle = angle === 90 ? '#3498db' : '#333';
                    ctx.font = angle === 90 ? `bold ${Math.max(12, radius * 0.045)}px Arial` : `${Math.max(10, radius * 0.04)}px Arial`;
                    ctx.fillText(angle.toString(), labelX, labelY);
                }
            }
            
            // Draw center point
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#e74c3c';
            ctx.fill();
        }
        
        // Calculate sun position
        function calculateSunPosition(date) {
            // Get day of year
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));
            
            // Calculate solar declination
            const declination = 23.45 * Math.sin((360 * (284 + dayOfYear) / 365) * Math.PI / 180);
            
            // Calculate hour angle
            const hours = date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
            const hourAngle = 15 * (hours - 12);
            
            // Calculate solar elevation angle
            const elevationRad = Math.asin(
                Math.sin(declination * Math.PI / 180) * Math.sin(LATITUDE * Math.PI / 180) +
                Math.cos(declination * Math.PI / 180) * Math.cos(LATITUDE * Math.PI / 180) * Math.cos(hourAngle * Math.PI / 180)
            );
            const elevation = elevationRad * 180 / Math.PI;
            
            // Calculate solar azimuth
            const azimuthRad = Math.atan2(
                Math.sin(hourAngle * Math.PI / 180),
                Math.cos(hourAngle * Math.PI / 180) * Math.sin(LATITUDE * Math.PI / 180) - 
                Math.tan(declination * Math.PI / 180) * Math.cos(LATITUDE * Math.PI / 180)
            );
            let azimuth = (azimuthRad * 180 / Math.PI + 180) % 360;
            
            // Calculate sunrise and sunset times
            const sunriseHourAngle = Math.acos(
                -Math.tan(LATITUDE * Math.PI / 180) * Math.tan(declination * Math.PI / 180)
            ) * 180 / Math.PI;
            
            const sunrise = 12 - sunriseHourAngle / 15;
            const sunset = 12 + sunriseHourAngle / 15;
            
            return {
                elevation: Math.max(0, elevation), // Ensure elevation is not negative
                azimuth: azimuth,
                sunrise: sunrise,
                sunset: sunset
            };
        }
        
        // Draw sun
        function drawSun(elevation, azimuth, timeFraction) {
            if (elevation <= 0) return; // Don't draw sun if below horizon
            
            // Calculate position based on time of day and elevation
            // Map time fraction to protractor angle (0째 to 180째)
            const protractorAngle = timeFraction * 180;
            
            // Convert to radians for canvas coordinates
            const angleRad = (180 - protractorAngle) * Math.PI / 180;
            
            // Calculate position on the protractor arc
            const sunX = centerX + radius * Math.cos(angleRad);
            const sunY = centerY - radius * Math.sin(angleRad);
            
            // Draw sun
            const sunRadius = Math.max(10, radius * 0.06);
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#f1c40f';
            ctx.fill();
            
            // Draw sun rays
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = Math.max(1, radius * 0.005);
            for (let i = 0; i < 12; i++) {
                const rayAngle = i * Math.PI / 6;
                const startX = sunX + (sunRadius + 5) * Math.cos(rayAngle);
                const startY = sunY + (sunRadius + 5) * Math.sin(rayAngle);
                const endX = sunX + (sunRadius + 15) * Math.cos(rayAngle);
                const endY = sunY + (sunRadius + 15) * Math.sin(rayAngle);
                
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
            
            // Draw line from center to sun
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(sunX, sunY);
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw elevation angle arc
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.7, Math.PI, angleRad, true);
            ctx.strokeStyle = 'rgba(52, 152, 219, 0.7)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw elevation angle text
            const textX = centerX + (radius * 0.5) * Math.cos((Math.PI + angleRad) / 2);
            const textY = centerY - (radius * 0.5) * Math.sin((Math.PI + angleRad) / 2);
            
            ctx.fillStyle = '#3498db';
            ctx.font = `bold ${Math.max(12, radius * 0.04)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(`${elevation.toFixed(1)}째`, textX, textY);
        }
        
        // Update simulation
        function updateSimulation(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            
            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;
            
            if (isPlaying) {
                // Advance simulation time based on speed
                const speedMultiplier = parseInt(speedSlider.value);
                simulationDate.setSeconds(simulationDate.getSeconds() + (deltaTime / 1000) * speedMultiplier);
                
                // Update time input
                timeInput.value = formatTime(simulationDate);
            }
            
            // Get date and time from inputs
            const dateParts = dateInput.value.split('-');
            const timeParts = timeInput.value.split(':');
            
            if (dateParts.length === 3 && timeParts.length === 2) {
                const simDate = new Date(
                    parseInt(dateParts[0]),
                    parseInt(dateParts[1]) - 1,
                    parseInt(dateParts[2]),
                    parseInt(timeParts[0]),
                    parseInt(timeParts[1])
                );
                
                // Calculate sun position
                const sunPosition = calculateSunPosition(simDate);
                
                // Calculate time fraction (0 = sunrise, 1 = sunset)
                const currentHour = simDate.getHours() + simDate.getMinutes() / 60;
                const timeFraction = Math.max(0, Math.min(1, 
                    (currentHour - sunPosition.sunrise) / (sunPosition.sunset - sunPosition.sunrise)
                ));
                
                // Update background based on sun elevation
                updateBackground(sunPosition.elevation);
                
                // Update display
                currentTimeElement.textContent = formatTimeWithSeconds(simDate);
                sunAngleElement.textContent = `${sunPosition.elevation.toFixed(1)}째`;
                azimuthElement.textContent = `${sunPosition.azimuth.toFixed(1)}째`;
                
                // Format sunrise and sunset times
                const sunriseHours = Math.floor(sunPosition.sunrise);
                const sunriseMinutes = Math.floor((sunPosition.sunrise - sunriseHours) * 60);
                const sunsetHours = Math.floor(sunPosition.sunset);
                const sunsetMinutes = Math.floor((sunPosition.sunset - sunsetHours) * 60);
                
                sunriseElement.textContent = `${sunriseHours.toString().padStart(2, '0')}:${sunriseMinutes.toString().padStart(2, '0')}`;
                sunsetElement.textContent = `${sunsetHours.toString().padStart(2, '0')}:${sunsetMinutes.toString().padStart(2, '0')}`;
                
                // Draw protractor and sun
                drawProtractor();
                drawSun(sunPosition.elevation, sunPosition.azimuth, timeFraction);
            }
            
            // Continue animation
            animationId = requestAnimationFrame(updateSimulation);
        }
        
        // Event listeners
        playButton.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playButton.textContent = isPlaying ? 'Pause' : 'Play';
        });
        
        dateInput.addEventListener('change', () => {
            const dateParts = dateInput.value.split('-');
            if (dateParts.length === 3) {
                simulationDate = new Date(
                    parseInt(dateParts[0]),
                    parseInt(dateParts[1]) - 1,
                    parseInt(dateParts[2]),
                    simulationDate.getHours(),
                    simulationDate.getMinutes()
                );
            }
        });
        
        timeInput.addEventListener('change', () => {
            const timeParts = timeInput.value.split(':');
            if (timeParts.length === 2) {
                simulationDate.setHours(parseInt(timeParts[0]));
                simulationDate.setMinutes(parseInt(timeParts[1]));
            }
        });
        
        // UPDATED: Event listener for the speed slider
        speedSlider.addEventListener('input', () => {
            const speed = parseInt(speedSlider.value);
            // Check the speed value to display a more meaningful message
            if (speed < 60) {
                speedValue.textContent = `${speed}x`;
            } else if (speed < 3600) {
                const minutesPerSecond = (speed / 60).toFixed(0);
                speedValue.textContent = `${minutesPerSecond} min/sec`;
            } else {
                const hoursPerSecond = (speed / 3600).toFixed(0);
                speedValue.textContent = `${hoursPerSecond} hour/sec`;
            }
        });
        
        function redraw() {
            const dateParts = dateInput.value.split('-');
            const timeParts = timeInput.value.split(':');

            if (dateParts.length === 3 && timeParts.length >= 2) {
                const simDate = new Date(
                    parseInt(dateParts[0]),
                    parseInt(dateParts[1]) - 1,
                    parseInt(dateParts[2]),
                    parseInt(timeParts[0]),
                    parseInt(timeParts[1])
                );

                const sunPosition = calculateSunPosition(simDate);
                const currentHour = simDate.getHours() + simDate.getMinutes() / 60;
                const timeFraction = Math.max(0, Math.min(1,
                    (currentHour - sunPosition.sunrise) / (sunPosition.sunset - sunPosition.sunrise)
                ));

                updateBackground(sunPosition.elevation);
                drawProtractor();
                drawSun(sunPosition.elevation, sunPosition.azimuth, timeFraction);
            }
        }

        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const newWidth = container.clientWidth;
            
            canvas.width = newWidth;
            canvas.height = newWidth * 0.667; // Maintain 3:2 aspect ratio

            centerX = canvas.width / 2;
            centerY = canvas.height - Math.min(50, canvas.height * 0.1);
            radius = Math.min(centerX, centerY) * 0.9;
            
            redraw();
        }

        // Initialize and start simulation
        initializeDateTime();
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        animationId = requestAnimationFrame(updateSimulation);
    </script>
</body>
</html>
